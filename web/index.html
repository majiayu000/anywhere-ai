<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anywhere AI Chat</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8fafc;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            background: white;
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #1f2937;
        }

        .status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ef4444;
        }

        .status-dot.connected {
            background: #10b981;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Main Container */
        .container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: 260px;
            background: white;
            border-right: 1px solid #e5e7eb;
            display: flex;
            flex-direction: column;
        }

        .new-session {
            margin: 1rem;
            padding: 0.75rem;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
        }

        .new-session:hover {
            background: #2563eb;
        }

        .sessions {
            flex: 1;
            overflow-y: auto;
            padding: 0 1rem;
        }

        .session {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: background 0.2s;
        }

        .session:hover {
            background: #f9fafb;
        }

        .session.active {
            background: #eff6ff;
            border-color: #3b82f6;
        }

        .session-name {
            font-weight: 500;
            margin-bottom: 0.25rem;
        }

        .session-info {
            font-size: 0.8rem;
            color: #6b7280;
        }

        /* Chat Area */
        .chat {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
            min-height: 0;
            overflow: hidden;
        }

        .chat-header {
            padding: 1rem;
            border-bottom: 1px solid #e5e7eb;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .clear-btn {
            padding: 0.5rem 1rem;
            background: #f3f4f6;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            color: #6b7280;
            cursor: pointer;
            font-size: 0.875rem;
        }

        .clear-btn:hover {
            background: #e5e7eb;
        }

        .messages {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            max-height: calc(100vh - 200px);
            min-height: 200px;
            scroll-behavior: smooth;
            /* ç¡®ä¿æ»šåŠ¨æ¡å¯è§ */
            scrollbar-width: thin;
        }

        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡æ ·å¼ */
        .messages::-webkit-scrollbar {
            width: 6px;
        }

        .messages::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .messages::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }

        .messages::-webkit-scrollbar-thumb:hover {
            background: #a1a1a1;
        }

        .message {
            display: flex;
            gap: 0.75rem;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            flex-shrink: 0;
        }

        .message.user .avatar {
            background: #10b981;
            color: white;
        }

        .message.agent .avatar {
            background: #3b82f6;
            color: white;
        }

        .content {
            flex: 1;
        }

        .sender {
            font-weight: 600;
            margin-bottom: 0.25rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .time {
            font-size: 0.75rem;
            color: #9ca3af;
        }

        .text {
            line-height: 1.5;
            color: #374151;
            word-wrap: break-word;
        }

        .text pre {
            background: #f3f4f6;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            padding: 0.5rem;
            overflow-x: auto;
            margin: 0.5rem 0;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.875rem;
        }

        .text code {
            background: #f3f4f6;
            padding: 0.125rem 0.25rem;
            border-radius: 3px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.875rem;
        }

        /* Typing Animation */
        .typing-indicator {
            display: flex;
            gap: 0.75rem;
            padding: 0.5rem 0;
            animation: fadeIn 0.3s ease;
        }

        .typing-indicator .avatar {
            background: #3b82f6;
            color: white;
        }

        .typing-dots {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: #f3f4f6;
            border-radius: 1rem;
            max-width: 150px;
        }

        .typing-dots::before {
            content: "ğŸ¤– Claude æ€è€ƒä¸­";
            font-size: 0.875rem;
            color: #6b7280;
        }

        .typing-dots::after {
            content: "...";
            animation: typing 1.5s infinite;
            font-weight: bold;
            color: #3b82f6;
        }

        @keyframes typing {
            0%, 20% { content: ""; }
            40% { content: "."; }
            60% { content: ".."; }
            80%, 100% { content: "..."; }
        }

        /* Input Area */
        .input-area {
            padding: 1rem;
            border-top: 1px solid #e5e7eb;
            background: white;
        }

        .input-wrapper {
            display: flex;
            gap: 0.75rem;
            align-items: flex-end;
        }

        .input-box {
            flex: 1;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 0.75rem;
            transition: border-color 0.2s;
        }

        .input-box:focus-within {
            border-color: #3b82f6;
            background: white;
        }

        .message-input {
            width: 100%;
            background: transparent;
            border: none;
            outline: none;
            resize: none;
            font-family: inherit;
            min-height: 20px;
            max-height: 100px;
        }

        .send-btn {
            padding: 0.75rem 1.5rem;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
        }

        .send-btn:hover:not(:disabled) {
            background: #2563eb;
        }

        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .send-btn.loading {
            background: #9ca3af;
            position: relative;
            overflow: hidden;
        }

        .send-btn.loading::before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            animation: loading-shimmer 1.5s infinite;
        }

        @keyframes loading-shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        /* Empty State */
        .empty {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #9ca3af;
        }

        .empty h3 {
            margin-bottom: 0.5rem;
            color: #4b5563;
        }

        /* Loading */
        .loading {
            text-align: center;
            color: #9ca3af;
            font-style: italic;
            padding: 2rem;
        }

        /* Command Autocomplete */
        .autocomplete-container {
            position: relative;
        }

        .autocomplete-dropdown {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 6px 6px 0 0;
            box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.1);
            max-height: 200px;
            overflow-y: auto;
            display: none;
            z-index: 1000;
        }

        .autocomplete-dropdown.show {
            display: block;
        }

        .autocomplete-item {
            padding: 0.75rem;
            cursor: pointer;
            border-bottom: 1px solid #f3f4f6;
            transition: background 0.2s;
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        .autocomplete-item:hover,
        .autocomplete-item.selected {
            background: #eff6ff;
        }

        .autocomplete-command {
            font-weight: 600;
            color: #3b82f6;
            font-family: 'Monaco', 'Consolas', monospace;
        }

        .autocomplete-description {
            font-size: 0.875rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="title">ğŸ¤– Anywhere AI Chat</div>
        <div class="status">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">è¿æ¥ä¸­...</span>
        </div>
    </div>

    <div class="container">
        <!-- Sidebar -->
        <div class="sidebar">
            <button class="new-session" onclick="createNewSession()">
                âœ¨ æ–°å»ºä¼šè¯
            </button>
            <div class="sessions" id="sessionsList">
                <div class="loading">åŠ è½½ä¸­...</div>
            </div>
        </div>

        <!-- Chat Area -->
        <div class="chat">
            <!-- Empty State -->
            <div class="empty" id="emptyState">
                <h3>ğŸ’¬ è¯·é€‰æ‹©æˆ–åˆ›å»ºä¼šè¯</h3>
                <p>ä»å·¦ä¾§é€‰æ‹©ä¸€ä¸ªä¼šè¯æˆ–åˆ›å»ºæ–°ä¼šè¯å¼€å§‹å¯¹è¯</p>
            </div>

            <!-- Chat Interface -->
            <div id="chatInterface" style="display: none; flex: 1; flex-direction: column; height: 100%; overflow: hidden;">
                <div class="chat-header">
                    <span id="chatTitle">Claude ä¼šè¯</span>
                    <div style="display: flex; gap: 0.5rem;">
                        <button class="clear-btn" onclick="forceScrollToBottom()">æ»šåŠ¨åˆ°åº•éƒ¨</button>
                        <button class="clear-btn" onclick="clearMessages()">æ¸…ç©ºæ¶ˆæ¯</button>
                    </div>
                </div>

                <div class="messages" id="messagesContainer">
                    <!-- Messages will appear here -->
                </div>

                <div class="input-area">
                    <div class="input-wrapper">
                        <div class="input-box autocomplete-container">
                            <!-- Autocomplete Dropdown -->
                            <div class="autocomplete-dropdown" id="autocompleteDropdown">
                                <!-- Autocomplete items will appear here -->
                            </div>
                            
                            <textarea 
                                class="message-input" 
                                id="messageInput" 
                                placeholder="è¾“å…¥æ‚¨çš„æ¶ˆæ¯... (è¾“å…¥ / æŸ¥çœ‹å‘½ä»¤)"
                                onkeydown="handleKeyPress(event)"
                                oninput="autoResize(this); handleInput(event)"
                                oncompositionstart="handleCompositionStart(event)"
                                oncompositionend="handleCompositionEnd(event)"
                                oncompositionupdate="isComposing = true"
                            ></textarea>
                        </div>
                        <button class="send-btn" onclick="sendMessage()" id="sendBtn">
                            å‘é€
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:8080';
        let ws = null;
        let currentSessionId = null;
        let sessions = [];
        let messages = [];
        let isTyping = false;
        let typingTimeout = null;
        let isComposing = false; // IME è¾“å…¥çŠ¶æ€
        let lastCompositionEnd = 0; // æœ€åä¸€æ¬¡compositionç»“æŸæ—¶é—´

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            loadSessions();
            connectWebSocket();
            loadClaudeCommands(); // åŠ è½½æœ€æ–°çš„Claudeå‘½ä»¤åˆ—è¡¨
            
            // ç‚¹å‡»å…¶ä»–åœ°æ–¹éšè—è‡ªåŠ¨è¡¥å…¨
            document.addEventListener('click', (event) => {
                const dropdown = document.getElementById('autocompleteDropdown');
                const inputArea = document.querySelector('.input-area');
                
                if (dropdown.classList.contains('show') && 
                    !inputArea.contains(event.target)) {
                    hideAutocomplete();
                }
            });
        });

        // WebSocket Connection
        function connectWebSocket() {
            ws = new WebSocket(`ws://localhost:8080/api/v1/ws`);
            
            ws.onopen = () => {
                console.log('WebSocketè¿æ¥æˆåŠŸ');
                updateStatus(true, 'å·²è¿æ¥');
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleWebSocketMessage(data);
            };

            ws.onclose = () => {
                console.log('WebSocketè¿æ¥æ–­å¼€');
                updateStatus(false, 'è¿æ¥æ–­å¼€');
                setTimeout(connectWebSocket, 3000);
            };

            ws.onerror = (error) => {
                console.error('WebSocketé”™è¯¯:', error);
                updateStatus(false, 'è¿æ¥é”™è¯¯');
            };
        }

        // Update Connection Status
        function updateStatus(connected, text) {
            const dot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            
            if (connected) {
                dot.classList.add('connected');
                statusText.textContent = text || 'å·²è¿æ¥';
            } else {
                dot.classList.remove('connected');
                statusText.textContent = text || 'æœªè¿æ¥';
            }
        }

        // Handle WebSocket Messages
        function handleWebSocketMessage(data) {
            switch(data.action) {
                case 'messages':
                    if (data.sessionId === currentSessionId) {
                        messages = data.data || [];
                        renderMessages();
                    }
                    break;
                    
                case 'newMessage':
                    if (data.sessionId === currentSessionId && data.data) {
                        const message = data.data;
                        
                        // æ”¶åˆ°Agentæ¶ˆæ¯æ—¶éšè—è¾“å…¥åŠ¨ç”»
                        if (message.sender_type === 'AGENT') {
                            hideTypingIndicator();
                        }
                        
                        messages.push(message);
                        renderMessages();
                        scrollToBottom();
                    }
                    break;
                    
                case 'typing':
                    if (data.sessionId === currentSessionId) {
                        showTypingIndicator();
                    }
                    break;
                    
                case 'stopTyping':
                    if (data.sessionId === currentSessionId) {
                        hideTypingIndicator();
                    }
                    break;
            }
        }

        // Load Sessions
        async function loadSessions() {
            try {
                const response = await fetch(`${API_BASE}/api/v1/terminal/sessions`);
                if (response.ok) {
                    sessions = await response.json();
                    renderSessions();
                }
            } catch (error) {
                console.error('åŠ è½½ä¼šè¯å¤±è´¥:', error);
                document.getElementById('sessionsList').innerHTML = 
                    '<div style="color: #ef4444; text-align: center; padding: 1rem;">åŠ è½½å¤±è´¥</div>';
            }
        }

        // Render Sessions
        function renderSessions() {
            const container = document.getElementById('sessionsList');
            
            if (sessions.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #9ca3af; padding: 1rem;">æš‚æ— ä¼šè¯</div>';
                return;
            }

            container.innerHTML = sessions.map(session => `
                <div class="session ${session.id === currentSessionId ? 'active' : ''}" 
                     onclick="selectSession('${session.id}')">
                    <div class="session-name">
                        ğŸ¤– ${session.name || session.id}
                    </div>
                    <div class="session-info">
                        ${session.tool} â€¢ ${session.status === 'active' ? 'è¿è¡Œä¸­' : 'å·²åœæ­¢'}
                    </div>
                </div>
            `).join('');
        }

        // Select Session
        async function selectSession(sessionId) {
            // é‡ç½®è¾“å…¥çŠ¶æ€
            hideTypingIndicator();
            
            currentSessionId = sessionId;
            const session = sessions.find(s => s.id === sessionId);
            
            if (session) {
                document.getElementById('emptyState').style.display = 'none';
                document.getElementById('chatInterface').style.display = 'flex';
                document.getElementById('chatTitle').textContent = `ğŸ¤– ${session.name || session.id}`;
                
                // æ¸…ç©ºæ¶ˆæ¯
                messages = [];
                document.getElementById('messagesContainer').innerHTML = '';
                
                // è®¢é˜…ä¼šè¯
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ 
                        action: 'subscribe', 
                        sessionId: sessionId 
                    }));
                    
                    ws.send(JSON.stringify({
                        action: 'selectSession',
                        sessionId: sessionId
                    }));
                }
                
                renderSessions();
            }
        }

        // Render Messages
        function renderMessages() {
            const container = document.getElementById('messagesContainer');
            
            if (messages.length === 0 && !isTyping) {
                container.innerHTML = '<div class="loading">æš‚æ— æ¶ˆæ¯ï¼Œå¼€å§‹å¯¹è¯å§ï¼</div>';
                return;
            }

            let html = messages.map(msg => {
                const isAgent = msg.sender_type === 'AGENT';
                const time = new Date(msg.created_at).toLocaleTimeString();
                
                return `
                    <div class="message ${isAgent ? 'agent' : 'user'}">
                        <div class="avatar">
                            ${isAgent ? 'ğŸ¤–' : 'ğŸ‘¤'}
                        </div>
                        <div class="content">
                            <div class="sender">
                                ${isAgent ? 'Claude' : 'æˆ‘'}
                                <span class="time">${time}</span>
                            </div>
                            <div class="text">${formatMessage(msg.content)}</div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // æ·»åŠ è¾“å…¥åŠ¨ç”»
            if (isTyping) {
                html += `
                    <div class="typing-indicator">
                        <div class="avatar">ğŸ¤–</div>
                        <div class="typing-dots"></div>
                    </div>
                `;
            }
            
            container.innerHTML = html;
            // å»¶è¿Ÿæ»šåŠ¨ç¡®ä¿DOMå·²æ›´æ–°
            setTimeout(() => scrollToBottom(), 50);
        }

        // Format Message Content
        function formatMessage(content) {
            // HTMLè½¬ä¹‰
            content = content.replace(/&/g, '&amp;')
                           .replace(/</g, '&lt;')
                           .replace(/>/g, '&gt;');
            
            // ä»£ç å—
            content = content.replace(/```([\s\S]*?)```/g, '<pre>$1</pre>');
            
            // è¡Œå†…ä»£ç 
            content = content.replace(/`([^`]+)`/g, '<code>$1</code>');
            
            // æ¢è¡Œ
            content = content.replace(/\n/g, '<br>');
            
            return content;
        }

        // Send Message
        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (!message || !currentSessionId || isComposing) return;

            // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            const sendBtn = document.getElementById('sendBtn');
            sendBtn.disabled = true;
            sendBtn.classList.add('loading');
            sendBtn.textContent = 'å‘é€ä¸­...';

            try {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        action: 'sendMessage',
                        sessionId: currentSessionId,
                        input: message
                    }));
                    
                    input.value = '';
                    autoResize(input);
                    
                    // æ˜¾ç¤ºè¾“å…¥åŠ¨ç”»
                    showTypingIndicator();
                }
            } catch (error) {
                console.error('å‘é€æ¶ˆæ¯å¤±è´¥:', error);
                hideTypingIndicator();
            } finally {
                // é‡ç½®å‘é€æŒ‰é’®
                setTimeout(() => {
                    sendBtn.disabled = false;
                    sendBtn.classList.remove('loading');
                    sendBtn.textContent = 'å‘é€';
                }, 1000);
            }
        }

        // Show/Hide Typing Indicator
        function showTypingIndicator() {
            if (!isTyping && currentSessionId) {
                isTyping = true;
                renderMessages();
                
                // 30ç§’åè‡ªåŠ¨éšè—
                typingTimeout = setTimeout(() => {
                    hideTypingIndicator();
                }, 30000);
            }
        }

        function hideTypingIndicator() {
            if (isTyping) {
                isTyping = false;
                if (typingTimeout) {
                    clearTimeout(typingTimeout);
                    typingTimeout = null;
                }
                renderMessages();
            }
        }

        // Handle Key Press & IME - é‡æ–°è®¾è®¡
        function handleKeyPress(event) {
            // é¦–å…ˆå¤„ç†è‡ªåŠ¨è¡¥å…¨å¯¼èˆª
            if (handleAutocompleteNavigation(event)) {
                return; // å¦‚æœå¤„ç†äº†è‡ªåŠ¨è¡¥å…¨å¯¼èˆªï¼Œç›´æ¥è¿”å›
            }

            // å…³é”®ï¼šåªæœ‰åœ¨ç¡®è®¤ä¸æ˜¯è¾“å…¥æ³•çŠ¶æ€æ—¶æ‰å¤„ç†Enter
            if (event.key === 'Enter' && !event.shiftKey) {
                // å¦‚æœæ­£åœ¨è¾“å…¥æ³•ç»„åˆä¸­ï¼Œå®Œå…¨ä¸å¤„ç†ï¼Œè®©è¾“å…¥æ³•è‡ªå·±å¤„ç†
                if (isComposing) {
                    console.log('åœ¨è¾“å…¥æ³•ç»„åˆä¸­ï¼Œè®©è¾“å…¥æ³•å¤„ç†Enteré”®');
                    return; // ä¸è°ƒç”¨ preventDefaultï¼Œè®©è¾“å…¥æ³•é€‰è¯
                }
                
                // åˆšç»“æŸè¾“å…¥æ³•é€‰è¯åçš„çŸ­æš‚æ—¶é—´å†…ä¹Ÿä¸å¤„ç†
                const now = Date.now();
                if (now - lastCompositionEnd < 150) {
                    console.log('åˆšç»“æŸè¾“å…¥æ³•ï¼Œç­‰å¾…ä¸€ä¸‹');
                    return;
                }
                
                // åªæœ‰åœ¨éè¾“å…¥æ³•çŠ¶æ€ä¸‹æ‰å‘é€æ¶ˆæ¯
                console.log('å‘é€æ¶ˆæ¯');
                event.preventDefault();
                sendMessage();
            }
        }

        function handleCompositionStart(event) {
            console.log('ğŸŒ è¾“å…¥æ³•å¼€å§‹:', event.data);
            isComposing = true;
        }

        function handleCompositionEnd(event) {
            console.log('ğŸŒ è¾“å…¥æ³•ç»“æŸ:', event.data);
            isComposing = false;
            lastCompositionEnd = Date.now();
        }

        // Command autocomplete data - ä»å®˜æ–¹æ–‡æ¡£åŠ¨æ€è·å–
        let claudeCommands = [
            // é»˜è®¤å‘½ä»¤ï¼Œå½“ç½‘ç»œè¯·æ±‚å¤±è´¥æ—¶ä½¿ç”¨
            { command: '/help', description: 'è·å–ä½¿ç”¨å¸®åŠ©' },
            { command: '/clear', description: 'æ¸…ç©ºå¯¹è¯å†å²' },
            { command: '/status', description: 'æŸ¥çœ‹è´¦æˆ·å’Œç³»ç»ŸçŠ¶æ€' },
            { command: '/model', description: 'é€‰æ‹©æˆ–æ›´æ”¹AIæ¨¡å‹' }
        ];

        // ä»å®˜æ–¹æ–‡æ¡£è·å–æœ€æ–°å‘½ä»¤åˆ—è¡¨
        async function loadClaudeCommands() {
            try {
                // å°è¯•é€šè¿‡åç«¯ä»£ç†è·å–å‘½ä»¤åˆ—è¡¨
                const response = await fetch(`${API_BASE}/api/v1/claude-commands`);
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.commands && data.commands.length > 0) {
                        claudeCommands = data.commands.map(cmd => ({
                            command: cmd.command,
                            description: translateDescription(cmd.description)
                        }));
                        console.log(`âœ… é€šè¿‡åç«¯ä»£ç†æˆåŠŸåŠ è½½ ${claudeCommands.length} ä¸ªClaudeå‘½ä»¤`);
                        return;
                    }
                }
                
                // å¦‚æœåç«¯ä»£ç†å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨å®Œæ•´åˆ—è¡¨
                claudeCommands = [
                    { command: '/add-dir', description: 'æ·»åŠ é¢å¤–çš„å·¥ä½œç›®å½•' },
                    { command: '/agents', description: 'ç®¡ç†ä¸“ç”¨ä»»åŠ¡çš„è‡ªå®šä¹‰AIå­ä»£ç†' },
                    { command: '/bug', description: 'æŠ¥å‘Šé”™è¯¯ï¼ˆå‘é€å¯¹è¯åˆ°Anthropicï¼‰' },
                    { command: '/clear', description: 'æ¸…ç©ºå¯¹è¯å†å²' },
                    { command: '/compact', description: 'å‹ç¼©å¯¹è¯ï¼Œå¯é€‰èšç„¦æŒ‡ä»¤' },
                    { command: '/config', description: 'æŸ¥çœ‹/ä¿®æ”¹é…ç½®' },
                    { command: '/cost', description: 'æ˜¾ç¤ºtokenä½¿ç”¨ç»Ÿè®¡' },
                    { command: '/doctor', description: 'æ£€æŸ¥Claude Codeå®‰è£…å¥åº·çŠ¶æ€' },
                    { command: '/help', description: 'è·å–ä½¿ç”¨å¸®åŠ©' },
                    { command: '/init', description: 'ä½¿ç”¨CLAUDE.mdæŒ‡å—åˆå§‹åŒ–é¡¹ç›®' },
                    { command: '/login', description: 'åˆ‡æ¢Anthropicè´¦æˆ·' },
                    { command: '/logout', description: 'é€€å‡ºAnthropicè´¦æˆ·' },
                    { command: '/mcp', description: 'ç®¡ç†MCPæœåŠ¡å™¨è¿æ¥å’ŒOAuthè®¤è¯' },
                    { command: '/memory', description: 'ç¼–è¾‘CLAUDE.mdè®°å¿†æ–‡ä»¶' },
                    { command: '/model', description: 'é€‰æ‹©æˆ–æ›´æ”¹AIæ¨¡å‹' },
                    { command: '/permissions', description: 'æŸ¥çœ‹æˆ–æ›´æ–°æƒé™' },
                    { command: '/pr_comments', description: 'æŸ¥çœ‹æ‹‰å–è¯·æ±‚è¯„è®º' },
                    { command: '/review', description: 'è¯·æ±‚ä»£ç å®¡æŸ¥' },
                    { command: '/status', description: 'æŸ¥çœ‹è´¦æˆ·å’Œç³»ç»ŸçŠ¶æ€' },
                    { command: '/terminal-setup', description: 'å®‰è£…Shift+Enteræ¢è¡Œé”®ç»‘å®š' },
                    { command: '/vim', description: 'è¿›å…¥vimæ¨¡å¼ï¼Œäº¤æ›¿æ’å…¥å’Œå‘½ä»¤æ¨¡å¼' }
                ];
                console.log('ğŸ“‹ ä½¿ç”¨å†…ç½®å®Œæ•´å‘½ä»¤åˆ—è¡¨');
                
            } catch (error) {
                console.error('âŒ è·å–Claudeå‘½ä»¤å¤±è´¥:', error);
                // ç½‘ç»œé”™è¯¯æ—¶ä½¿ç”¨å¤‡ç”¨å‘½ä»¤åˆ—è¡¨
                claudeCommands = [
                    { command: '/add-dir', description: 'æ·»åŠ é¢å¤–çš„å·¥ä½œç›®å½•' },
                    { command: '/agents', description: 'ç®¡ç†ä¸“ç”¨ä»»åŠ¡çš„è‡ªå®šä¹‰AIå­ä»£ç†' },
                    { command: '/bug', description: 'æŠ¥å‘Šé”™è¯¯ï¼ˆå‘é€å¯¹è¯åˆ°Anthropicï¼‰' },
                    { command: '/clear', description: 'æ¸…ç©ºå¯¹è¯å†å²' },
                    { command: '/compact', description: 'å‹ç¼©å¯¹è¯ï¼Œå¯é€‰èšç„¦æŒ‡ä»¤' },
                    { command: '/config', description: 'æŸ¥çœ‹/ä¿®æ”¹é…ç½®' },
                    { command: '/cost', description: 'æ˜¾ç¤ºtokenä½¿ç”¨ç»Ÿè®¡' },
                    { command: '/doctor', description: 'æ£€æŸ¥Claude Codeå®‰è£…å¥åº·çŠ¶æ€' },
                    { command: '/help', description: 'è·å–ä½¿ç”¨å¸®åŠ©' },
                    { command: '/init', description: 'ä½¿ç”¨CLAUDE.mdæŒ‡å—åˆå§‹åŒ–é¡¹ç›®' },
                    { command: '/login', description: 'åˆ‡æ¢Anthropicè´¦æˆ·' },
                    { command: '/logout', description: 'é€€å‡ºAnthropicè´¦æˆ·' },
                    { command: '/mcp', description: 'ç®¡ç†MCPæœåŠ¡å™¨è¿æ¥å’ŒOAuthè®¤è¯' },
                    { command: '/memory', description: 'ç¼–è¾‘CLAUDE.mdè®°å¿†æ–‡ä»¶' },
                    { command: '/model', description: 'é€‰æ‹©æˆ–æ›´æ”¹AIæ¨¡å‹' },
                    { command: '/permissions', description: 'æŸ¥çœ‹æˆ–æ›´æ–°æƒé™' },
                    { command: '/pr_comments', description: 'æŸ¥çœ‹æ‹‰å–è¯·æ±‚è¯„è®º' },
                    { command: '/review', description: 'è¯·æ±‚ä»£ç å®¡æŸ¥' },
                    { command: '/status', description: 'æŸ¥çœ‹è´¦æˆ·å’Œç³»ç»ŸçŠ¶æ€' },
                    { command: '/terminal-setup', description: 'å®‰è£…Shift+Enteræ¢è¡Œé”®ç»‘å®š' },
                    { command: '/vim', description: 'è¿›å…¥vimæ¨¡å¼ï¼Œäº¤æ›¿æ’å…¥å’Œå‘½ä»¤æ¨¡å¼' }
                ];
                console.log('ğŸ”„ ä½¿ç”¨å¤‡ç”¨å‘½ä»¤åˆ—è¡¨');
            }
        }

        // ç¿»è¯‘å¸¸è§å‘½ä»¤æè¿°
        function translateDescription(desc) {
            const translations = {
                'Add additional working directories': 'æ·»åŠ é¢å¤–çš„å·¥ä½œç›®å½•',
                'Manage custom AI subagents for specialized tasks': 'ç®¡ç†ä¸“ç”¨ä»»åŠ¡çš„è‡ªå®šä¹‰AIå­ä»£ç†',
                'Report bugs (sends conversation to Anthropic)': 'æŠ¥å‘Šé”™è¯¯ï¼ˆå‘é€å¯¹è¯åˆ°Anthropicï¼‰',
                'Clear conversation history': 'æ¸…ç©ºå¯¹è¯å†å²',
                'Compact conversation with optional focus instructions': 'å‹ç¼©å¯¹è¯ï¼Œå¯é€‰èšç„¦æŒ‡ä»¤',
                'View/modify configuration': 'æŸ¥çœ‹/ä¿®æ”¹é…ç½®',
                'Show token usage statistics': 'æ˜¾ç¤ºtokenä½¿ç”¨ç»Ÿè®¡',
                'Checks the health of your Claude Code installation': 'æ£€æŸ¥Claude Codeå®‰è£…å¥åº·çŠ¶æ€',
                'Get usage help': 'è·å–ä½¿ç”¨å¸®åŠ©',
                'Initialize project with CLAUDE.md guide': 'ä½¿ç”¨CLAUDE.mdæŒ‡å—åˆå§‹åŒ–é¡¹ç›®',
                'Switch Anthropic accounts': 'åˆ‡æ¢Anthropicè´¦æˆ·',
                'Sign out from your Anthropic account': 'é€€å‡ºAnthropicè´¦æˆ·',
                'Manage MCP server connections and OAuth authentication': 'ç®¡ç†MCPæœåŠ¡å™¨è¿æ¥å’ŒOAuthè®¤è¯',
                'Edit CLAUDE.md memory files': 'ç¼–è¾‘CLAUDE.mdè®°å¿†æ–‡ä»¶',
                'Select or change the AI model': 'é€‰æ‹©æˆ–æ›´æ”¹AIæ¨¡å‹',
                'View or update permissions': 'æŸ¥çœ‹æˆ–æ›´æ–°æƒé™',
                'View pull request comments': 'æŸ¥çœ‹æ‹‰å–è¯·æ±‚è¯„è®º',
                'Request code review': 'è¯·æ±‚ä»£ç å®¡æŸ¥',
                'View account and system statuses': 'æŸ¥çœ‹è´¦æˆ·å’Œç³»ç»ŸçŠ¶æ€',
                'Install Shift+Enter key binding for newlines': 'å®‰è£…Shift+Enteræ¢è¡Œé”®ç»‘å®š',
                'Enter vim mode for alternating insert and command modes': 'è¿›å…¥vimæ¨¡å¼ï¼Œäº¤æ›¿æ’å…¥å’Œå‘½ä»¤æ¨¡å¼'
            };
            
            return translations[desc] || desc;
        }

        let selectedCommandIndex = -1;

        // ç›‘å¬inputäº‹ä»¶ï¼Œè¾…åŠ©åˆ¤æ–­è¾“å…¥æ³•çŠ¶æ€å’Œå‘½ä»¤è¡¥å…¨
        function handleInput(event) {
            // ä½¿ç”¨ event.isComposing ä½œä¸ºé¢å¤–çš„åˆ¤æ–­ä¾æ®
            if (event.isComposing !== undefined && event.isComposing !== isComposing) {
                console.log('ğŸ“ Input event æ£€æµ‹åˆ°è¾“å…¥æ³•çŠ¶æ€å˜åŒ–:', event.isComposing);
                isComposing = event.isComposing;
            }

            // å¤„ç†å‘½ä»¤è‡ªåŠ¨è¡¥å…¨
            const input = event.target;
            const value = input.value;
            const cursorPosition = input.selectionStart;
            
            // æ£€æŸ¥å…‰æ ‡ä½ç½®çš„æ–‡æœ¬æ˜¯å¦ä»¥ / å¼€å¤´
            const textBeforeCursor = value.substring(0, cursorPosition);
            const lastSlashIndex = textBeforeCursor.lastIndexOf('/');
            
            if (lastSlashIndex !== -1 && lastSlashIndex === textBeforeCursor.length - 1) {
                // åˆšè¾“å…¥ /ï¼Œæ˜¾ç¤ºæ‰€æœ‰å‘½ä»¤
                showAutocomplete(claudeCommands, '');
            } else if (lastSlashIndex !== -1) {
                // æœ‰ / ä¸”åé¢æœ‰æ–‡æœ¬ï¼Œè¿›è¡Œç­›é€‰
                const commandText = textBeforeCursor.substring(lastSlashIndex);
                if (commandText.startsWith('/') && commandText.length > 1) {
                    const query = commandText.toLowerCase();
                    const filteredCommands = claudeCommands.filter(cmd => 
                        cmd.command.toLowerCase().includes(query)
                    );
                    if (filteredCommands.length > 0) {
                        showAutocomplete(filteredCommands, query);
                    } else {
                        hideAutocomplete();
                    }
                } else if (commandText === '/') {
                    showAutocomplete(claudeCommands, '');
                }
            } else {
                hideAutocomplete();
            }
        }

        // æ˜¾ç¤ºè‡ªåŠ¨è¡¥å…¨ä¸‹æ‹‰æ¡†
        function showAutocomplete(commands, query) {
            const dropdown = document.getElementById('autocompleteDropdown');
            selectedCommandIndex = -1;
            
            dropdown.innerHTML = commands.map((cmd, index) => `
                <div class="autocomplete-item" data-index="${index}" onclick="selectCommand('${cmd.command}')">
                    <div class="autocomplete-command">${cmd.command}</div>
                    <div class="autocomplete-description">${cmd.description}</div>
                </div>
            `).join('');
            
            dropdown.classList.add('show');
        }

        // éšè—è‡ªåŠ¨è¡¥å…¨ä¸‹æ‹‰æ¡†
        function hideAutocomplete() {
            const dropdown = document.getElementById('autocompleteDropdown');
            dropdown.classList.remove('show');
            selectedCommandIndex = -1;
        }

        // é€‰æ‹©å‘½ä»¤
        function selectCommand(command) {
            const input = document.getElementById('messageInput');
            const value = input.value;
            const cursorPosition = input.selectionStart;
            
            // æ‰¾åˆ°æœ€åä¸€ä¸ª / çš„ä½ç½®
            const textBeforeCursor = value.substring(0, cursorPosition);
            const lastSlashIndex = textBeforeCursor.lastIndexOf('/');
            
            if (lastSlashIndex !== -1) {
                // æ›¿æ¢ä» / å¼€å§‹åˆ°å…‰æ ‡ä½ç½®çš„æ–‡æœ¬
                const newValue = value.substring(0, lastSlashIndex) + command + ' ' + value.substring(cursorPosition);
                input.value = newValue;
                
                // è®¾ç½®å…‰æ ‡ä½ç½®åˆ°å‘½ä»¤åé¢
                const newCursorPos = lastSlashIndex + command.length + 1;
                input.setSelectionRange(newCursorPos, newCursorPos);
            }
            
            hideAutocomplete();
            input.focus();
        }

        // å¤„ç†é”®ç›˜å¯¼èˆª
        function handleAutocompleteNavigation(event) {
            const dropdown = document.getElementById('autocompleteDropdown');
            if (!dropdown.classList.contains('show')) return false;
            
            const items = dropdown.querySelectorAll('.autocomplete-item');
            if (items.length === 0) return false;
            
            switch(event.key) {
                case 'ArrowDown':
                    event.preventDefault();
                    selectedCommandIndex = (selectedCommandIndex + 1) % items.length;
                    updateSelectedCommand(items);
                    return true;
                    
                case 'ArrowUp':
                    event.preventDefault();
                    selectedCommandIndex = selectedCommandIndex <= 0 ? items.length - 1 : selectedCommandIndex - 1;
                    updateSelectedCommand(items);
                    return true;
                    
                case 'Enter':
                    if (selectedCommandIndex >= 0 && selectedCommandIndex < items.length) {
                        event.preventDefault();
                        const selectedCommand = items[selectedCommandIndex].querySelector('.autocomplete-command').textContent;
                        selectCommand(selectedCommand);
                        return true;
                    }
                    break;
                    
                case 'Escape':
                    hideAutocomplete();
                    return true;
            }
            
            return false;
        }

        // æ›´æ–°é€‰ä¸­çš„å‘½ä»¤æ ·å¼
        function updateSelectedCommand(items) {
            items.forEach((item, index) => {
                if (index === selectedCommandIndex) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
        }

        // Auto Resize Textarea
        function autoResize(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 100) + 'px';
        }

        // Create New Session
        async function createNewSession() {
            try {
                const response = await fetch(`${API_BASE}/api/v1/terminal/sessions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        tool: 'claude', 
                        name: `claude-${Date.now()}` 
                    })
                });

                if (response.ok) {
                    const session = await response.json();
                    await loadSessions();
                    selectSession(session.id);
                }
            } catch (error) {
                console.error('åˆ›å»ºä¼šè¯å¤±è´¥:', error);
            }
        }

        // Clear Messages
        function clearMessages() {
            messages = [];
            hideTypingIndicator();
            renderMessages();
        }

        // Scroll to Bottom
        function scrollToBottom() {
            const container = document.getElementById('messagesContainer');
            if (container) {
                // ä½¿ç”¨ requestAnimationFrame ç¡®ä¿DOMå·²æ›´æ–°
                requestAnimationFrame(() => {
                    container.scrollTop = container.scrollHeight;
                });
            }
        }

        // å¼ºåˆ¶æ»šåŠ¨åˆ°åº•éƒ¨ï¼ˆè°ƒè¯•ç”¨ï¼‰
        function forceScrollToBottom() {
            const container = document.getElementById('messagesContainer');
            if (container) {
                container.scrollTo({
                    top: container.scrollHeight,
                    behavior: 'smooth'
                });
                console.log(`æ»šåŠ¨: scrollHeight=${container.scrollHeight}, scrollTop=${container.scrollTop}`);
            }
        }
    </script>
</body>
</html>